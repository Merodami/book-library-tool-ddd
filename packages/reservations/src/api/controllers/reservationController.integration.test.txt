import express from 'express'
import request from 'supertest'
import {
  describe,
  beforeAll,
  beforeEach,
  afterAll,
  test,
  expect,
  vi,
} from 'vitest'
import cors from 'cors'
import { randomUUID } from 'crypto'
import { ReservationController } from '@controllers/reservationController.js'
import { RESERVATION_STATUS } from '@book-library-tool/types'
import {
  schemas,
  validateBody,
  validateParams,
  validateQuery,
} from '@book-library-tool/api'
import { setUpTestDatabase } from '@book-library-tool/database'

// Mock external dependencies
vi.mock('@book-library-tool/sdk', () => {
  return {
    apiWallet: {
      default: {
        postWalletsBalance: vi.fn().mockResolvedValue({
          userId: 'mock-user-id',
          balance: 10,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        }),
        patchWalletsLateReturn: vi.fn().mockResolvedValue({
          message: 'Late fee applied',
          wallet: {
            userId: 'mock-user-id',
            balance: 0,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          },
        }),
      },
    },
    apiBooks: {
      default: {
        getBooks: vi.fn().mockResolvedValue({
          data: [{ isbn: 'any-isbn', price: 10 }],
        }),
      },
    },
  }
})

// Set environment variables for testing
process.env.BOOK_RETURN_DUE_DATE_DAYS = '5'
process.env.BOOK_RESERVATION_FEE = '3'
process.env.LATE_FEE_PER_DAY = '0.2'

describe('ReservationController Integration Tests', () => {
  // Set up the test database using mongodb-memory-server
  const dbSetup = setUpTestDatabase({ randomUUID })
  let app: express.Express
  let mockReservationService: any

  // Sample valid UUIDs for testing
  const validUserId = randomUUID()
  const validReservationId = randomUUID()
  const invalidReservationId = 'not-a-valid-uuid'

  // Common headers for requests
  const commonHeaders = {
    'Content-Type': 'application/json',
    Accept: 'application/json',
    Authorization: 'Bearer test-token',
  }

  beforeAll(async () => {
    // Set up the in-memory database and environment variables
    await dbSetup.beforeAllCallback()

    // Mock the ReservationService with simplified mock implementation
    mockReservationService = {
      createReservation: vi.fn(),
      getReservationHistory: vi.fn(),
      returnReservation: vi.fn(),
    }

    // Success case for createReservation
    mockReservationService.createReservation.mockImplementation(
      async (data) => {
        const now = new Date()
        const dueDate = new Date(now.getTime() + 5 * 24 * 60 * 60 * 1000)

        return {
          reservationId: randomUUID(),
          userId: data.userId,
          isbn: data.isbn,
          reservedAt: now.toISOString(),
          dueDate: dueDate.toISOString(),
          status: RESERVATION_STATUS.RESERVED,
          feeCharged: 3,
          createdAt: now.toISOString(),
          updatedAt: now.toISOString(),
        }
      },
    )

    // Success case for getReservationHistory
    mockReservationService.getReservationHistory.mockImplementation(
      async (userId) => {
        return {
          data: [
            {
              reservationId: randomUUID(),
              userId,
              isbn: 'test-isbn-1',
              reservedAt: new Date().toISOString(),
              dueDate: new Date().toISOString(),
              status: RESERVATION_STATUS.RESERVED,
              feeCharged: 3,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
            },
          ],
          pagination: {
            total: 1,
            page: 1,
            limit: 10,
            pages: 1,
            hasNext: false,
            hasPrev: false,
          },
        }
      },
    )

    // Success case for returnReservation
    mockReservationService.returnReservation.mockImplementation(
      async (reservationId) => {
        return {
          message: `Reservation marked as ${RESERVATION_STATUS.RETURNED}.`,
          late_fee_applied: '0.0',
          days_late: 0,
          status: RESERVATION_STATUS.RETURNED,
        }
      },
    )

    // Create a new instance of ReservationController with the mocked service
    const reservationController = new ReservationController(
      mockReservationService,
    )

    // Set up the express application and register routes
    app = express().disable('x-powered-by').use(cors()).use(express.json())

    app.post(
      '/reservations',
      validateBody(schemas.ReservationRequestSchema),
      async (req, res, next) => {
        try {
          await reservationController.createReservation(req, res, next)
        } catch (error) {
          next(error)
        }
      },
    )

    app.get(
      '/reservations/user/:userId',
      validateParams(schemas.UserIdSchema),
      validateQuery(schemas.ReservationsHistoryQuerySchema),
      async (req, res, next) => {
        try {
          await reservationController.getReservationHistory(req, res, next)
        } catch (error) {
          next(error)
        }
      },
    )

    app.patch(
      '/reservations/:reservationId/return',
      validateParams(schemas.ReservationReturnParamsSchema),
      async (req, res, next) => {
        try {
          await reservationController.returnReservation(req, res, next)
        } catch (error) {
          next(error)
        }
      },
    )

    // Add error handler
    app.use(
      (
        err: any,
        req: express.Request,
        res: express.Response,
        next: express.NextFunction,
      ) => {
        res
          .status(err.status || 500)
          .json({ error: err.message || 'Internal Server Error' })
      },
    )
  })

  beforeEach(async () => {
    // Reset all mocks before each test
    vi.clearAllMocks()

    // Clear all collections for a clean state before each test
    await dbSetup.beforeEachCallback()
  })

  afterAll(async () => {
    await dbSetup.afterAllCallback()
  })

  describe('POST /reservations', () => {
    test('should create a new reservation with valid input', async () => {
      const payload = {
        userId: validUserId,
        isbn: '978-3-16-148410-0',
      }

      const response = await request(app)
        .post('/reservations')
        .set(commonHeaders)
        .send(payload)

      expect(response.status).toBe(201)
      expect(response.body).toHaveProperty('reservationId')
      expect(response.body).toMatchObject({
        userId: payload.userId,
        isbn: payload.isbn,
        status: RESERVATION_STATUS.RESERVED,
      })
      expect(mockReservationService.createReservation).toHaveBeenCalledWith(
        payload,
      )
    })

    test('should return 400 if userId is missing', async () => {
      const payload = {
        isbn: '978-3-16-148410-0',
        // Missing userId
      }

      const response = await request(app)
        .post('/reservations')
        .set(commonHeaders)
        .send(payload)

      expect(response.status).toBe(400)
      expect(response.body).toHaveProperty('error')
      // We don't check specific error message since it depends on the validation library
    })

    test('should return 400 if isbn is missing', async () => {
      const payload = {
        userId: validUserId,
        // Missing isbn
      }

      const response = await request(app)
        .post('/reservations')
        .set(commonHeaders)
        .send(payload)

      expect(response.status).toBe(400)
      expect(response.body).toHaveProperty('error')
      // We don't check specific error message since it depends on the validation library
    })

    // For the following tests, we need to handle the errors at the service level
    // instead of relying on the validation middleware

    test('should handle book already reserved scenario', async () => {
      // Setup mock to throw error
      mockReservationService.createReservation.mockRejectedValueOnce({
        status: 409,
        message: 'BOOK_ALREADY_RESERVED',
      })

      const payload = {
        userId: validUserId,
        isbn: 'already-reserved',
      }

      const response = await request(app)
        .post('/reservations')
        .set(commonHeaders)
        .send(payload)

      expect(response.status).toBe(409)
      expect(response.body).toHaveProperty('error')
      expect(response.body.error).toBe('BOOK_ALREADY_RESERVED')
    })

    test('should handle book not found scenario', async () => {
      // Setup mock to throw error
      mockReservationService.createReservation.mockRejectedValueOnce({
        status: 404,
        message: 'BOOK_NOT_FOUND',
      })

      const payload = {
        userId: validUserId,
        isbn: 'not-found',
      }

      const response = await request(app)
        .post('/reservations')
        .set(commonHeaders)
        .send(payload)

      expect(response.status).toBe(404)
      expect(response.body).toHaveProperty('error')
      expect(response.body.error).toBe('BOOK_NOT_FOUND')
    })

    test('should handle maximum reservations reached scenario', async () => {
      // Setup mock to throw error
      mockReservationService.createReservation.mockRejectedValueOnce({
        status: 400,
        message: 'MAX_RESERVATIONS_REACHED',
      })

      const payload = {
        userId: 'max-reservations',
        isbn: '978-3-16-148410-0',
      }

      const response = await request(app)
        .post('/reservations')
        .set(commonHeaders)
        .send(payload)

      expect(response.status).toBe(400)
      expect(response.body).toHaveProperty('error')
      expect(response.body.error).toBe('MAX_RESERVATIONS_REACHED')
    })
  })

  describe('GET /reservations/user/:userId', () => {
    test('should return reservation history with valid userId', async () => {
      const response = await request(app)
        .get(`/reservations/user/${validUserId}`)
        .set(commonHeaders)
        .query({ page: 1, limit: 10 })

      expect(response.status).toBe(200)
      expect(response.body).toHaveProperty('data')
      expect(Array.isArray(response.body.data)).toBe(true)
      expect(response.body.data.length).toBeGreaterThan(0)
      expect(mockReservationService.getReservationHistory).toHaveBeenCalledWith(
        validUserId,
      )
    })

    test('should return empty array when user has no reservations', async () => {
      // Setup mock to return empty results
      mockReservationService.getReservationHistory.mockResolvedValueOnce({
        data: [],
        pagination: {
          total: 0,
          page: 1,
          limit: 10,
          pages: 0,
          hasNext: false,
          hasPrev: false,
        },
      })

      const response = await request(app)
        .get(`/reservations/user/${validUserId}`)
        .set(commonHeaders)
        .query({ page: 1, limit: 10 })

      expect(response.status).toBe(200)
      expect(response.body).toHaveProperty('data')
      expect(Array.isArray(response.body.data)).toBe(true)
      expect(response.body.data.length).toBe(0)
    })

    test('should handle user not found scenario', async () => {
      // Setup mock to throw error
      mockReservationService.getReservationHistory.mockRejectedValueOnce({
        status: 404,
        message: 'USER_NOT_FOUND',
      })

      const response = await request(app)
        .get(`/reservations/user/user-not-found`)
        .set(commonHeaders)
        .query({ page: 1, limit: 10 })

      expect(response.status).toBe(404)
      expect(response.body).toHaveProperty('error')
      expect(response.body.error).toBe('USER_NOT_FOUND')
    })

    test('should handle database errors', async () => {
      // Setup mock to throw error
      mockReservationService.getReservationHistory.mockRejectedValueOnce({
        status: 500,
        message: 'DATABASE_ERROR',
      })

      const response = await request(app)
        .get(`/reservations/user/${validUserId}`)
        .set(commonHeaders)
        .query({ page: 1, limit: 10 })

      expect(response.status).toBe(500)
      expect(response.body).toHaveProperty('error')
      expect(response.body.error).toBe('DATABASE_ERROR')
    })

    test('should apply pagination parameters', async () => {
      const response = await request(app)
        .get(`/reservations/user/${validUserId}`)
        .set(commonHeaders)
        .query({ page: 2, limit: 5 })

      expect(response.status).toBe(200)
      expect(response.body).toHaveProperty('pagination')
      expect(mockReservationService.getReservationHistory).toHaveBeenCalledWith(
        validUserId,
      )
    })
  })

  describe('PATCH /reservations/:reservationId/return', () => {
    test('should mark reservation as returned successfully', async () => {
      const response = await request(app)
        .patch(`/reservations/${validReservationId}/return`)
        .set(commonHeaders)
        .send()

      expect(response.status).toBe(200)
      expect(response.body).toHaveProperty('message')
      expect(response.body.message).toContain('Reservation marked as')
      expect(response.body.status).toBe(RESERVATION_STATUS.RETURNED)
      expect(mockReservationService.returnReservation).toHaveBeenCalledWith(
        validReservationId,
      )
    })

    test('should handle late returns with fees', async () => {
      // Setup mock to return late fee result
      mockReservationService.returnReservation.mockResolvedValueOnce({
        message: `Reservation marked as ${RESERVATION_STATUS.RETURNED} with late fees.`,
        late_fee_applied: '5.0',
        days_late: 10,
        status: RESERVATION_STATUS.RETURNED,
      })

      const response = await request(app)
        .patch(`/reservations/late-return/return`)
        .set(commonHeaders)
        .send()

      expect(response.status).toBe(200)
      expect(response.body).toHaveProperty('late_fee_applied')
      expect(response.body.late_fee_applied).toBe('5.0')
      expect(response.body.days_late).toBe(10)
    })

    test('should handle reservation not found scenario', async () => {
      // Setup mock to throw error
      mockReservationService.returnReservation.mockRejectedValueOnce({
        status: 404,
        message: 'RESERVATION_NOT_FOUND',
      })

      const response = await request(app)
        .patch(`/reservations/not-found/return`)
        .set(commonHeaders)
        .send()

      expect(response.status).toBe(404)
      expect(response.body).toHaveProperty('error')
      expect(response.body.error).toBe('RESERVATION_NOT_FOUND')
    })

    test('should handle invalid reservation status', async () => {
      // Setup mock to throw error
      mockReservationService.returnReservation.mockRejectedValueOnce({
        status: 400,
        message: 'INVALID_RESERVATION_STATUS',
      })

      const response = await request(app)
        .patch(`/reservations/already-returned/return`)
        .set(commonHeaders)
        .send()

      expect(response.status).toBe(400)
      expect(response.body).toHaveProperty('error')
      expect(response.body.error).toBe('INVALID_RESERVATION_STATUS')
    })

    test('should handle invalid reservationId format', async () => {
      // For this test, relying on validation middleware is appropriate
      const response = await request(app)
        .patch(`/reservations/invalid-uuid/return`)
        .set(commonHeaders)
        .send()

      expect(response.status).toBe(400)
      expect(response.body).toHaveProperty('error')
      // We don't check specific error message since it depends on the validation library
    })
  })
})
