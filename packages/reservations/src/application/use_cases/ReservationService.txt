import { EventBus } from '@book-library-tool/event-store'
import { ReservationRequest } from '@book-library-tool/sdk'
import { Errors } from '@book-library-tool/shared'
import { RESERVATION_STATUS } from '@book-library-tool/types'
import { Reservation } from '@entities/Reservation.js'
import { IReservationRepositoryEvent } from '@repositories/IReservationRepositoryEvent.js'

export class ReservationService {
  constructor(
    private readonly reservationRepository: IReservationRepositoryEvent,
    private readonly eventBus: EventBus,
  ) {}

  /**
   * Creates a new reservation.
   *
   * In the event‑sourced flow, the reservation aggregate is created
   * and a ReservationCreated event is produced. That event is persisted and published.
   * Downstream, a saga orchestrator (listening on the EventBus) will trigger
   * operations such as wallet fund deduction.
   *
   * @param data - The reservation request data.
   * @returns The newly created Reservation aggregate.
   */
  async createReservation(data: ReservationRequest): Promise<Reservation> {
    // Create the Reservation aggregate from the command. This returns both the aggregate and the ReservationCreated event.
    const { reservation, event } = Reservation.create({
      userId: data.userId.trim(),
      isbn: data.isbn.trim(),
      reservedAt: new Date().toISOString(),
      status: RESERVATION_STATUS.RESERVED, // or use your RESERVATION_STATUS.RESERVED constant
    })

    const existingReservation =
      await this.reservationRepository.findActiveByUserAndIsbn(
        reservation.userId,
        reservation.isbn,
      )

    if (existingReservation) {
      throw new Errors.ApplicationError(
        400,
        'RESERVATION_ALREADY_EXISTS',
        `Reservation already exists for user ${reservation.userId} and ISBN ${reservation.isbn}.`,
      )
    }

    // Persist the ReservationCreated event to the event store.
    // For a new aggregate, expected version is 0.
    await this.reservationRepository.saveEvents(
      reservation.reservationId,
      [event],
      0,
    )

    // Publish the event asynchronously on the EventBus.
    await this.eventBus.publish(event)

    // Return the new aggregate.
    return reservation
  }

  /**
   * Retrieves the reservation history for a given user.
   *
   * @param userId - The user identifier.
   * @returns An array of Reservation aggregates.
   */
  async getReservationHistory(userId: string): Promise<Reservation[]> {
    return this.reservationRepository.findByUserId(userId)
  }

  /**
   * Processes the return of a reservation.
   *
   * In an event‑sourced system, this method rehydrates the Reservation aggregate,
   * calls a domain method (here: markAsReturned) that produces a ReservationReturned event,
   * then persists and publishes the resulting event.
   * A saga orchestrator can listen for this event and trigger subsequent processes like wallet updates.
   *
   * @param reservationId - The reservation identifier.
   * @returns An object containing outcome information.
   */
  async returnReservation(
    reservationId: string,
  ): Promise<{ message: string; lateFeeApplied: string; daysLate: number }> {
    // Load all events for the reservation.
    const events =
      await this.reservationRepository.getEventsForAggregate(reservationId)

    if (!events || events.length === 0) {
      throw new Errors.ApplicationError(
        404,
        'RESERVATION_NOT_FOUND',
        `Reservation with id ${reservationId} not found.`,
      )
    }
    // Rehydrate the Reservation aggregate from its event stream.
    const reservation = Reservation.rehydrate(events)

    // Execute the return process on the aggregate.
    // In our updated aggregate the method is now markAsReturned().
    const { reservation: updatedReservation, event } =
      reservation.markAsReturned()

    // Persist the new event with optimistic concurrency (expected version is the current aggregate version).
    await this.reservationRepository.saveEvents(
      reservation.reservationId,
      [event],
      reservation.version,
    )

    // Publish the event so that the saga orchestrator (or other processors) can trigger wallet adjustments.
    await this.eventBus.publish(event)

    // Build the response using event payload data. Adjust property names based on your implementation.
    return {
      message: `Reservation return processed.`,
      lateFeeApplied: event.payload.lateFeeApplied
        ? event.payload.lateFeeApplied.toFixed(1)
        : '0.0',
      daysLate: event.payload.daysLate || 0,
    }
  }
}
